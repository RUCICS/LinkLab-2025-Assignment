# 任务六：引入只读数据段

在任务五中，我们将程序分成了代码段和数据段。现在让我们更仔细地审视"数据段"里到底装了什么。

假设你的程序中有这样的定义：

```c
const char *message = "Hello, World!";  // 指针变量，可以修改
int counter = 0;                         // 普通变量，可以修改

void print_message() {
    printf("%s\n", message);
}
```

编译器会生成三类数据：

- 字符串字面量`"Hello, World!"`会被放在`.rodata`节（只读数据）
- 指针变量`message`会被放在`.data`节（可读写数据）
- 变量`counter`也会被放在`.data`节

现在考虑一个问题：如果程序中存在一个缓冲区溢出漏洞，攻击者覆盖了`message`指针，让它指向攻击者精心构造的一个字符串。这很糟糕，但至少原来的字符串`"Hello, World!"`本身没有被破坏。

但是，如果我们把`.rodata`和`.data`混在同一个段中，并给予写权限，那么攻击者就有可能直接修改字符串字面量本身。这不仅会影响当前程序的行为，如果多个地方共享同一个字符串常量（编译器的常见优化），影响范围会更大。

## 常量应该是常量

在C语言中，`const`关键字表达的是一种约定——这个东西不应该被修改。编译器会将这些常量放在`.rodata`节，字面意思就是"只读数据"（Read-Only Data）。从语义上讲，这些内容在程序运行期间应该保持不变。

这不仅仅是安全考虑。将常量标记为只读还有其他好处。在某些系统中，只读的内存页可以在多个进程之间共享。如果你运行了十个相同程序的实例，它们可以共享同一份代码和常量数据的物理内存副本，而不需要为每个进程复制一份。这显著节省了内存。

现在你的任务是给只读数据一个独立的段。这样，程序的内存布局变成了三段式：

- 代码段：`.text`及其变体
- 只读数据段：`.rodata`及其变体
- 可读写数据段：`.data`、`.bss`及其他

## 识别只读数据节

在遍历目标文件的节时，你需要增加一个判断分支。之前你检查节名是否以`.text`开头来决定它是否属于代码段。现在你还需要检查是否以`.rodata`开头。

实际编译生成的目标文件中，你可能会遇到一些变体，比如`.rodata.str1.1`（字符串常量，特定对齐要求）、`.rodata.cst4`（4字节常量）等。这些都应该归入只读数据段。一个简单的判断方式是检查节名是否以`.rodata`开头。

在规划内存布局时，你需要决定这三个段的相对位置。一个常见的安排是：代码段在最前面，紧接着是只读数据段，最后是可读写数据段。这样的顺序有一定的逻辑——将"不会变"的内容（代码和常量）放在一起，将"会变"的内容（变量）放在另一侧。

每个段都应该从前一个段结束的地方继续。你需要维护三个累积的偏移量，分别追踪每个段当前的大小。在处理符号时，根据符号所在的节名判断它属于哪个段，然后使用对应段的基地址和段内偏移计算最终地址。

## 程序头数组的扩展

现在你有三个段，所以需要三个程序头。在任务五中，你已经学会了如何管理多个程序头，现在只是再添加一个。

创建程序头时，确保每个段的虚拟地址正确反映了它在内存中的位置。第一个段从`0x400000`开始，第二个段从第一个段结束的地方开始，第三个段从第二个段结束的地方开始。每个段的大小是它包含的所有节内容的总和。

在这个阶段，我们仍然给所有段相同的权限（`PHF::R | PHF::W | PHF::X`）。虽然从名字上看，"只读数据段"应该只有读权限，但我们把权限的细化留到下一个任务。现在的重点是建立正确的段分类，确保每类内容都去了它应该去的地方。

## 检查你的理解

完成这个任务后，你可以用一个简单的程序来验证理解：

```c
const char *msg = "test";
int x = 42;
```

链接后，`msg`字符串应该在只读数据段，指针变量`msg`和整数`x`应该在可读写数据段。你可以打印符号表或检查程序头，确认这个布局是否正确实现。

> [!TIP]
> 如果测试失败，一个常见的调试策略是打印每个节被分配到的段。检查节名的前缀判断逻辑是否正确，确认每个节都去了正确的段。另一个常见问题是符号地址计算——当你有三个段时，要确保使用了正确的段基地址。

完成后，运行测试来验证：

```bash
make test_6
```
