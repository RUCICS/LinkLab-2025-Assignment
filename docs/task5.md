# 任务五：代码与数据的分离

到目前为止，你的链接器可以处理多种重定位类型，也能正确决议符号冲突。但如果仔细观察我们生成的可执行文件，会发现一个问题：所有内容——代码、数据、常量——都被放在同一个内存段中，并且都具有读、写、执行的全部权限。

这在功能上没问题，程序能正常运行。但从系统安全的角度看，这是一个隐患。

## 为什么需要分离

在CSAPP的第三章中，你应该见过缓冲区溢出攻击。攻击者通过溢出覆盖栈上的返回地址，让程序跳转到攻击者准备的恶意代码。这类攻击之所以可能，部分原因就是数据区域具有可执行权限——攻击者可以把恶意指令写入缓冲区，然后诱导程序去执行它。

现代系统的一个重要防御机制是数据执行保护（DEP, Data Execution Prevention）。核心思想很简单：数据就是数据，不应该被当作代码执行；代码就是代码，不应该在运行时被修改。如果我们能把代码和数据放在不同的内存段，并给它们设置不同的权限，就能大大提高安全性。

但这里有个问题。回想一下目标文件的结构，编译器已经把不同类型的内容放在了不同的节中：

- `.text`节包含程序代码
- `.data`节包含已初始化的全局变量
- `.rodata`节包含只读常量（比如字符串字面量）
- `.bss`节为未初始化的全局变量预留空间

这些节在逻辑上已经完成了分类。但在任务二中，我们把所有节的内容拼接在了一起，形成一个大的内存块。现在的任务是将这个拼接过程变得更有结构。

## 两段式的内存布局

作为第一步，我们可以将程序分成两个段：一个代码段，一个数据段。代码段包含所有以`.text`开头的节（可能还有`.text.startup`、`.text.unlikely`这样的变体），数据段包含其他所有内容。

你可能会问：为什么不一开始就做更细致的分类？答案是我们在渐进式地建立理解。先建立"不同类型的内容应该分开放"这个基本概念，理解如何为每个段创建独立的程序头描述其加载位置。理解了这个框架之后，在后续任务中细化分类就会变得自然。

实现时，你需要调整任务二中的拼接逻辑。之前是把所有节的内容往一个数组里追加，现在需要根据节名判断它应该去哪个段。一个直观的做法是准备两个数组，一个用于代码段，一个用于数据段。遍历所有节时，检查节名前缀，决定将其内容追加到哪个数组。

在规划内存布局时，你需要为每个段分配一个起始地址。代码段可以继续从`0x400000`开始。数据段应该紧随其后，从代码段结束的地方继续。记得在拼接节的同时更新符号表——每个符号的最终地址取决于它所在的段的起始地址加上它在该段中的偏移。

> [!NOTE]
> 在这个阶段，我们暂时还不设置不同的权限。两个段都可以保持`PHF::R | PHF::W | PHF::X`的设置。这样做的好处是可以专注于理解多段布局的机制，而不用同时处理权限相关的问题。权限的细化是后续任务的内容。

## 程序头的管理

在任务二中，我们只有一个程序头。现在我们有两个段，就需要两个程序头。每个程序头描述一个段的加载信息：虚拟地址、大小、权限。

创建程序头时，确保每个段的虚拟地址和大小是正确的。虚拟地址是段在内存中的起始位置，大小是段包含的所有内容的总长度。这些信息需要在你拼接节的过程中累积计算。

在FLE格式中，可执行文件的`phdrs`字段是一个数组，你需要将两个程序头都添加进去。加载器会根据这些描述符将程序的不同部分加载到内存的相应位置。

## 调试的一些建议

在实现这个任务时，一个常见的问题是符号地址计算错误。当你引入多个段后，每个符号的地址不再是简单的"基地址 + 偏移"，而是"所在段的基地址 + 段内偏移"。在处理重定位时，如果发现计算出的地址明显不对，检查一下是否正确地使用了符号所在段的基地址。

另一个需要注意的是节的遍历顺序。当你将节分配到不同的段时，确保同一个目标文件的节保持相对顺序。虽然在这个任务中这可能不会造成明显问题，但保持一致的顺序是好的工程实践，也有助于调试。

> [!TIP]
> 你可以在生成可执行文件后，用我们提供的工具检查程序头的内容。确认每个段的大小和地址是否符合预期。如果程序运行出错，也可以通过检查程序头来判断是否是内存布局的问题。

完成后，运行测试来验证：

```bash
make test_5
```
